#' Visualize T-test Power for Pooling Design as Function of Processing Error
#' Variance
#'
#' Useful for choosing a sample size such that power will be adequate even if
#' the processing errors are larger than anticipated.
#'
#'
#' @param g Numeric value specifying the pool size.
#' @param n Numeric value specifying the number of assays per group.
#' @param mu1,mu2 Numeric value specifying group means. Required if
#' \code{multiplicative = TRUE}.
#' @param sigsq Numeric value specifying the variance of observations.
#' @param sigsq1,sigsq2 Numeric value specifying the variance of observations
#' for each group.
#' @param sigsq_p_range Numeric vector specifying range of processing error
#' variances to consider.
#' @param sigsq_m Numeric value specifying the variance of measurement errors.
#' @param multiplicative Logical value for whether to assume multiplicative
#' rather than additive errors.
#' @param alpha Numeric value specifying type-1 error rate.
#' @param labels Logical value.
#' @param ylim Numeric vector.
#'
#'
#' @return Plot generated by \code{\link[ggplot2]{ggplot}}.
#'
#'
#' @examples
#' # Plot ratio of variances vs. pool size with default settings
#' poolvar_t(sigsq = 1)
#'
#' # Add processing error and other per-subject costs
#' poolvar_t(sigsq = 1, sigsq_p = 0.2, other_costs = 0.1)
#'
#'
#'@export
poolcushion_t <- function(g = 2,
                          n = 100,
                          d = NULL,
                          mu1 = NULL,
                          mu2 = NULL,
                          sigsq = NULL,
                          sigsq1 = NULL,
                          sigsq2 = NULL,
                          sigsq_p_range = NULL,
                          sigsq_m = 0,
                          multiplicative = FALSE,
                          alpha = 0.05,
                          labels = TRUE,
                          ylim = NULL) {

  # Error checking
  if (! is.null(sigsq) & (! is.null(sigsq1) | ! is.null(sigsq2))) {
    stop("Please specify sigsq or specify sigsq1 and sigsq2")
  }
  if (multiplicative & (is.null(mu1) | is.null(mu2))) {
    stop("For multiplicative errors, you must specify mu1 and mu2")
  }

  # If sigsq specified, set sigsq1 = sigsq2 = sigsq
  if (! is.null(sigsq)) {
    sigsq1 <- sigsq2 <- sigsq
  }

  # If unspeciifed, create reasonable default range for sigsq_p
  if (is.null(sigsq_p_range)) {
    max_sigsq <- max(sigsq1, sigsq2)
    sigsq_p_range <- c(0, max_sigsq * 2)
  }

  # Create vector of sigsq_p values
  sigsq_p <- seq(sigsq_p_range[1], sigsq_p_range[2], diff(sigsq_p_range) / 1000)

  # Calculate power as a function of sigsq_p
  if (! multiplicative) {

    # Calculate d if mu1 and mu2 are specified
    if (is.null(d)) {
      d <- abs(mu1 - mu2)
    }

    # Calculate power as function of sigsq_p
    sigsq_pm <- sigsq_p * ifelse(g > 1, 1, 0) + sigsq_m
    power <- sapply(X = sigsq_pm, FUN = function(SIGSQ_PM) power_2t_unequal(
      n = n,
      d = d,
      sigsq1 = sigsq1 / g + SIGSQ_PM,
      sigsq2 = sigsq2 / g + SIGSQ_PM,
      alpha = alpha
    ))

  } else {

    # Check that mu1 and mu2 are specified and that mu1 > mu2
    if (is.null(mu1) | is.null(mu2)) {
      stop("For multiplicative errors, you have to specify mu1 and mu2.")
    } else if (mu1 <= mu2) {
      stop("mu1 should be larger than mu2")
    }

    # Calculate d
    if (is.null(d)) {
      d <- mu1 - mu2
    }

    # Calculate power as function of sigsq_p
    sigsq_pm <- sigsq_m + sigsq_p * (sigsq_m + 1) * ifelse(g > 1, 1, 0)

    # Calculate variance of errors
    sigsq_pm <- sigsq_m + sigsq_p * (sigsq_m + 1) * ifelse(g > 1, 1, 0)
    sigsq_group1 <- sigsq_pm * (mu1^2 + sigsq1 / g) + sigsq1 / g
    sigsq_group2 <- sigsq_pm * (mu2^2 + sigsq2 / g) + sigsq2 / g
    power <- mapply(
      FUN = function(SIGSQ_GROUP1, SIGSQ_GROUP2) {
        power_2t_unequal(
          n = n,
          d = d,
          sigsq1 = SIGSQ_GROUP1,
          sigsq2 = SIGSQ_GROUP2,
          alpha = alpha
        )
      },
      SIGSQ_GROUP1 = sigsq_group1,
      SIGSQ_GROUP2 = sigsq_group2
    )

  }

  # Prep for ggplot
  df <- data.frame(sigsq_p = sigsq_p, power = power)
  df$power.lab <- c(0, ifelse(diff(sign(df$power - 0.8)) < 0, 1, 0))

  # Exclude values with power outside of (1%, 99%)
  df <- df %>% dplyr::filter(power <= 0.99 & power >= 0.01)

  # Create labels
  df$powerlabel <- paste("sigma[p]^2 == ", df$sigsq_p, sep = "")

  # Create plot
  p <- ggplot(df, aes(sigsq_p, power)) +
    geom_point() +
    geom_line() +
    labs(title = "Power vs. Processing Error Variance",
         y = "Power",
         x = expression(sigma[p]^2)) +
    geom_hline(yintercept = c(0, 0.8, 0.9), linetype = 2) +
    theme_bw() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    scale_y_continuous(breaks = c(0, 0.8, 0.9))

  # Label last data point with 80% power
  if (labels) {
    power.lab <- NULL
    p <- p + geom_label_repel(
      data = subset(df, power.lab == 1),
      aes_string(x = "sigsq_p", y = "power", label = "powerlabel"),
      min.segment.length = 0,
      label.padding = 0.4,
      show.legend = FALSE,
      parse = TRUE
    )
  }
  p

}
