% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/p_linreg_yerrors.R
\name{p_linreg_yerrors}
\alias{p_linreg_yerrors}
\title{Linear Regression with Outcome Measured in Pools and (Potentially) Subject to
Errors}
\usage{
p_linreg_yerrors(g, ytilde, x = NULL, errors = "both",
  estimate_var = TRUE, ...)
}
\arguments{
\item{g}{Numeric vector with pool sizes, i.e. number of members in each pool.}

\item{ytilde}{Numeric vector (or list of numeric vectors, if some pools have
replicates) with poolwise sum \code{Ytilde} values.}

\item{x}{Numeric matrix with poolwise \strong{\code{X}} values (if any), with
one row for each pool. Can be a vector if there is only 1 covariate.}

\item{errors}{Character string specifying the errors that \code{Y} is subject
to. Choices are \code{"neither"}, \code{"processing"} for processing error
only, \code{"measurement"} for measurement error only, and \code{"both"}.}

\item{...}{Additional arguments to pass to \code{\link[stats]{nlminb}}.}
}
\value{
List containing:
\enumerate{
\item Numeric vector of parameter estimates.
\item Variance-covariance matrix (if \code{estimate_var = TRUE}).
\item Returned \code{\link[stats]{nlminb}} object from maximizing the
log-likelihood function.
\item Akaike information criterion (AIC).
}
}
\description{
Assumes outcome given exposure is a normal-errors linear regression. Pooled
outcome measurements can be assumed precise or subject to additive normal
processing error and/or measurement error. Replicates can be incorporated but
are not strictly required for identifiability, provided there are several
different pool sizes.
}
\examples{
# Load dataset containing data frame with (g, X1, X2, Y, Ytilde) values for
# 500 pools each of size 1, 2, and 3, and list of Ytilde values where 20 of
# the single-specimen pools have replicates. Ytilde values are affected by
# processing error and measurement error; true regression coefficients are
# (0.25, 0.5, 0.25).
data(dat_p_linreg_yerrors)
dat <- dat_p_linreg_yerrors$dat
reps <- dat_p_linreg_yerrors$reps

# Fit Ytilde vs. (X1, X2) ignoring errors in Ytilde (leads to loss of
# precision, but does not induce bias).
fit.naive <- p_linreg_yerrors(
  g = dat$g,
  y = dat$y,
  x = dat[, c("x1", "x2")],
  errors = "neither"
)
fit.naive$theta.hat

# Account for errors in Ytilde, without using replicates
fit.corrected.noreps <- p_linreg_yerrors(
  g = dat$g,
  y = dat$ytilde,
  x = dat[, x("x1", "x2")],
  errors = "both"
)
fit.corrected.noreps$theta.hat

# Account for errors in Ytilde, incorporating the 20 replicates
fit.corrected.reps <- p_linreg_yerrors(
  g = dat$g,
  y = reps,
  x = dat[, x("x1", "x2")],
  errors = "both"
)
fit.corrected.reps$theta.hat

# In this trial, incorporating replicates resulted in much better estimates
# of sigsq_p (truly 0.4) and sigsq_m (truly = 0.2) but very similar betahat's.
fit.corrected.noreps$theta.hat
fit.corrected.reps$theta.hat


}
\references{
Schisterman, E.F., Vexler, A., Mumford, S.L. and Perkins, N.J. (2010) "Hybrid
pooled-unpooled design for cost-efficient measurement of biomarkers."
\emph{Stat. Med.} \strong{29}(5): 597--613.
}
